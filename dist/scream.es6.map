{"version":3,"names":[],"mappings":"","sources":["scream.es6.js"],"sourcesContent":["class AmpEnvelope {\r\n\tconstructor (context, gain = 1) {\r\n\t\tthis.context = context;\r\n\t\tthis.output = this.context.createGain();\r\n\t\tthis.output.gain.value = gain;\r\n\t\tthis.partials = [];\r\n\t\tthis.velocity = 0;\r\n\t\tthis.gain = gain;\r\n\t\tthis.envelope = {\r\n\t\t\ta: 0,\r\n\t\t\td: 0.1,\r\n\t\t\ts: this.gain,\r\n\t\t\tr: 0.5\r\n\t\t};\r\n\t}\r\n\r\n\ton (velocity) {\r\n\t\tthis.velocity = velocity / 127;\r\n\t\tthis.start(this.context.currentTime);\r\n\t}\r\n\r\n\toff (MidiEvent) {\r\n\t\treturn this.stop(this.context.currentTime);\r\n\t}\r\n\r\n\tstart (time) {\r\n\t\tthis.output.gain.value = 0;\r\n\t\tthis.output.gain.setValueAtTime(0, time);\r\n\t\treturn this.output.gain.setTargetAtTime(this.sustain * this.velocity, time + this.attack, this.decay + 0.001);\r\n\t}\r\n\r\n\tstop (time) {\r\n\t\tthis.output.gain.cancelScheduledValues(time);\r\n\t\tthis.output.gain.setValueAtTime(this.sustain, time);\r\n\t\tthis.output.gain.setTargetAtTime(0, time, this.release);\r\n\t}\r\n\r\n\tset attack (value) {\r\n\t\tthis.envelope.a = value;\r\n\t}\r\n\r\n\tget attack () {\r\n\t\treturn this.envelope.a;\r\n\t}\r\n\r\n\tset decay (value) {\r\n\t\tthis.envelope.d = value;\r\n\t}\r\n\r\n\tget decay () {\r\n\t\treturn this.envelope.d;\r\n\t}\r\n\r\n\tset sustain (value) {\r\n\t\tthis.gain = value;\r\n\t\tthis.envelope.s = value;\r\n\t}\r\n\r\n\tget sustain () {\r\n\t\treturn this.gain;\r\n\t}\r\n\r\n\tset release (value) {\r\n\t\tthis.envelope.r = value;\r\n\t}\r\n\r\n\tget release () {\r\n\t\treturn this.envelope.r;\r\n\t}\r\n\r\n\tconnect (destination) {\r\n\t\tthis.output.connect(destination);\r\n\t}\r\n}\n\nconst FILTER_TYPES = [\"lowpass\", \"highpass\", \"bandpass\", \"lowshelf\", \"highshelf\", \"peaking\", \"notch\", \"allpass\"];\r\n\r\nconst BASE_SAMPLE_TUNING = 261.625565; // Middle C.\n\nclass Filter {\r\n\tconstructor (context, type = FILTER_TYPES[0], cutoff = 1000, resonance = 0.1) {\r\n\t\tthis.context = context;\r\n\t\tthis.destination = this.context.createBiquadFilter();\r\n\t\tthis.type = type;\r\n\t\tthis.cutoff = cutoff;\r\n\t\tthis.resonance = 0.5;\r\n\t\tthis.envelopeAmount = 1;\r\n\t\tthis.envelope = {\r\n\t\t\ta: 0,\r\n\t\t\td: 0.5,\r\n\t\t\ts: this.cutoff,\r\n\t\t\tr: 0.5\r\n\t\t};\r\n\t}\r\n\r\n\ton (MidiEvent) {\r\n\t\tthis.start(this.context.currentTime, MidiEvent.frequency);\r\n\t}\r\n\r\n\toff () {\r\n\t\treturn this.stop(this.context.currentTime);\r\n\t}\r\n\r\n\tset type (value) {\r\n\t\tthis.destination.type = value;\r\n\t}\r\n\r\n\tget type () {\r\n\t\treturn this.destination.type;\r\n\t}\r\n\r\n\tset cutoff (value) {\r\n\t\tthis.destination.frequency.value = value;\r\n\t}\r\n\r\n\tget cutoff () {\r\n\t\treturn this.destination.frequency.value;\r\n\t}\r\n\r\n\tset Q (value) {\r\n\t\tthis.destination.Q.value = value;\r\n\t}\r\n\r\n\tget Q () {\r\n\t\treturn this.destination.Q.value;\r\n\t}\r\n\r\n\tstart (time) {\r\n\t\treturn this.destination.frequency.setTargetAtTime(this.sustain, time + this.attack, this.decay + 0.001);\r\n\t}\r\n\r\n\tstop (time) {\r\n\t\treturn this.destination.frequency.setTargetAtTime(this.cutoff, time, this.release);\r\n\t}\r\n\r\n\tset attack (value) {\r\n\t\tthis.envelope.a = value;\r\n\t}\r\n\r\n\tget attack () {\r\n\t\treturn this.envelope.a;\r\n\t}\r\n\r\n\tset decay (value) {\r\n\t\tthis.envelope.d = value;\r\n\t}\r\n\r\n\tget decay () {\r\n\t\treturn this.envelope.d;\r\n\t}\r\n\r\n\tset sustain (value) {\r\n\t\tthis.cutoff = value;\r\n\t}\r\n\r\n\tget sustain () {\r\n\t\treturn this.cutoff;\r\n\t}\r\n\r\n\tset release (value) {\r\n\t\tthis.envelope.r = value;\r\n\t}\r\n\r\n\tget release () {\r\n\t\treturn this.envelope.r;\r\n\t}\r\n\r\n\tconnect (destination) {\r\n\t\tthis.destination.connect(destination);\r\n\t}\r\n}\n\nconst SAMPLE_BUFFER_SIZE = 1024;\r\n\r\nclass Sample {\r\n\tconstructor (context) {\r\n\r\n\t\tthis.context = context;\r\n\t\tthis.buffer = this.context.createBuffer(2, 1, this.context.sampleRate);\r\n\t\tthis.stream = null;\r\n\t\tthis._recordProcessor = null;\r\n\t}\r\n\r\n\tload (path) {\r\n\t\treturn fetch(path)\r\n\t\t\t.then((response) => response.arrayBuffer())\r\n\t\t\t.then((myBlob) => {\r\n\t\t\t\treturn this.context.decodeAudioData(myBlob);\r\n\t\t\t})\r\n\t\t\t.then((buffer) => {\r\n\t\t\t\tthis.buffer = buffer;\r\n\t\t\t})\r\n\t}\r\n\r\n\trecord () {\r\n\t\tthis.buffered = 0;\r\n\t\tthis.stream = new Float32Array(0);\r\n\t\tnavigator.mediaDevices.getUserMedia({audio: true, video: false})\r\n\t\t\t.then((stream) => {\r\n\t\t\t\tlet input = this.context.createMediaStreamSource(stream);\r\n\t\t\t\tthis._recordProcessor = this.context.createScriptProcessor(SAMPLE_BUFFER_SIZE, 1, 2);\r\n\r\n\t\t\t\tinput.connect(this._recordProcessor);\r\n\t\t\t\tthis._recordProcessor.connect(this.context.destination);\r\n\t\t\t\tthis._recordProcessor.onaudioprocess = (e) => {\r\n\t\t\t\t\tlet chunk = e.inputBuffer.getChannelData(0);\r\n\t\t\t\t\tvar newStream = new Float32Array(this.stream.length + chunk.length);\r\n\t\t\t\t\t\tnewStream.set(this.stream);\r\n\t\t\t\t\t\tnewStream.set(chunk,chunk.length * this.buffered);\r\n\t\t\t\t\t\tthis.stream = newStream;\r\n\t\t\t\t\tthis.buffered++;\r\n\t\t\t\t};\r\n\t\t\t});\r\n\t}\r\n\tstopRecording() {\r\n\t\tthis._recordProcessor.disconnect();\r\n\t\tthis.buffer = this.context.createBuffer(2, this.stream.length, this.context.sampleRate);\r\n\t\tthis.buffer.copyToChannel(this.stream, 0);\r\n\t\tthis.buffer.copyToChannel(this.stream, 1);\r\n\t}\r\n\r\n\trecordInput (input) {\r\n\r\n\t}\r\n\r\n}\n\nclass Effect {\r\n\r\n\tconstructor (context) {\r\n\t\tthis.context = context;\r\n\t\tthis.input = this.context.createGain();\r\n\t\tthis.effect = null;\r\n\t\tthis.output = this.context.createGain();\r\n\t\tthis.setup();\r\n\t\tthis.wireUp();\r\n\t}\r\n\r\n\tsetup() {\r\n\t\tthis.effect = this.context.createGain();\r\n\t}\r\n\r\n\twireUp() {\r\n\t\tthis.input.connect(this.effect);\r\n\t\tthis.effect.connect(this.output);\r\n\t}\r\n\r\n\tconnect(destination) {\r\n\t\tthis.output.connect(destination);\r\n\t}\r\n\r\n}\n\nclass Chorus extends Effect {\r\n\tconstructor () {\r\n\t\tsuper();\r\n\t}\r\n\r\n}\n\nclass Delay extends Effect {\r\n\tconstructor () {\r\n\t\tsuper();\r\n\t}\r\n\r\n}\n\nclass FFT extends Effect{\r\n\tconstructor (context) {\r\n\t\tsuper(context);\r\n\t}\r\n\r\n\tsetup () {\r\n\t\tthis.canvas = document.createElement(\"canvas\");\r\n\t\tthis.canvas.setAttribute(\"id\",\"fft\");\r\n\t\tthis.ctx = this.canvas.getContext(\"2d\");\r\n\t\tthis.ctx.canvas.width = 1024;\r\n\t\tthis.ctx.canvas.height = 400;\r\n\t\tthis.effect = this.context.createAnalyser();\r\n\t\tthis.effect.fftSize = 1024;\r\n\t\tthis.effect.maxDecibels = -50;\r\n\t\tthis.effect.minDecibels = -120;\r\n\t\tthis.effect.smoothingTimeConstant = 0.9;\r\n\t\tthis.effect.connect(this.output);\r\n\t\twindow.requestAnimationFrame(() => {\r\n\t\t\tthis.draw();\r\n\t\t});\r\n\t}\r\n\r\n\tdraw () {\r\n\t\tvar myDataArray = new Uint8Array(this.effect.frequencyBinCount);\r\n\t\tthis.effect.getByteFrequencyData(myDataArray);\r\n\r\n\t\tvar ctx = this.ctx;\r\n\t\tctx.save();\r\n\t\tctx.globalAlpha = 0.5;\r\n\t\tctx.fillStyle = \"rgb(33,33,99)\";\r\n\t\tctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n\t\tctx.restore();\r\n\t\tvar i = 0;\r\n\t\tvar width = (ctx.canvas.width / myDataArray.length);\r\n\r\n\t\tfor (var point in myDataArray) {\r\n\t\t\tctx.fillStyle = \"rgb(100,255,255)\";\r\n\t\t\tctx.fillRect(\r\n\t\t\t\t((width) * i),\r\n\t\t\t\tctx.canvas.height,\r\n\t\t\t\twidth,\r\n\t\t\t\t-(myDataArray[point]/255)*ctx.canvas.height);\r\n\t\t\ti++;\r\n\t\t}\r\n\r\n\t\twindow.requestAnimationFrame(() => {\r\n\t\t\tthis.draw();\r\n\t\t});\r\n\t}\r\n\tget element () {\r\n\t\treturn this.canvas;\r\n\t}\r\n\r\n\taddToElement(element) {\r\n\t\telement.appendChild(this.element);\r\n\t}\r\n}\n\nclass Filter$1 extends Effect {\r\n\tconstructor (context, type = FILTER_TYPES[0], cutoff = 1000, resonance = 0.9) {\r\n\t\tsuper(context);\r\n\t\tthis.effect.frequency.value = cutoff;\r\n\t\tthis.effect.Q.value = resonance;\r\n\t\tthis.effect.type = type;\r\n\t}\r\n\r\n\tsetup() {\r\n\t\tthis.effect = this.context.createBiquadFilter();\r\n\t\tthis.effect.connect(this.output);\r\n\t}\r\n\r\n}\n\nclass Voice {\r\n\tconstructor(context, type =\"sawtooth\") {\r\n\t\tthis.context = context;\r\n\t\tthis.type = type;\r\n\t\tthis.value = -1;\r\n\t\tthis.gain = 0.1;\r\n\t\tthis.output = this.context.createGain();\r\n\t\tthis.partials = [];\r\n\t\tthis.output.gain.value = this.gain;\r\n\t\tthis.ampEnvelope = new AmpEnvelope(this.context);\r\n\t\tthis.ampEnvelope.connect(this.output);\r\n\t}\r\n\r\n\tinit() {\r\n\t\tlet osc = this.context.createOscillator();\r\n\t\t\tosc.type = this.type;\r\n\t\t\tosc.connect(this.ampEnvelope.output);\r\n\t\t\tosc.start(this.context.currentTime);\r\n\t\tthis.partials.push(osc);\r\n\t}\r\n\r\n\ton(MidiEvent) {\r\n\t\tthis.value = MidiEvent.value;\r\n\t\tthis.partials.forEach((osc) => {\r\n\t\t\tosc.frequency.value = MidiEvent.frequency/4;\r\n\t\t});\r\n\t\tthis.ampEnvelope.on(MidiEvent.velocity || MidiEvent);\r\n\t}\r\n\r\n\toff(MidiEvent) {\r\n\t\tthis.ampEnvelope.off(MidiEvent);\r\n\t\tthis.partials.forEach((osc) => {\r\n\t\t\tosc.stop(this.context.currentTime + this.ampEnvelope.release * 4);\r\n\t\t});\r\n\t}\r\n\r\n\tconnect(destination) {\r\n\t\tthis.output.connect(destination);\r\n\t}\r\n}\n\nclass Noise extends Voice{\r\n\tconstructor(context, gain = 1) {\r\n\t\tsuper(context, \"none\");\r\n\t\tthis._length = 2;\r\n\t}\r\n\r\n\tget length () {\r\n\t\treturn this._length || 2;\r\n\t}\r\n\tset length (value) {\r\n\t\tthis._length = value;\r\n\t}\r\n\r\n\tinit() {\r\n\t\tvar lBuffer = new Float32Array(this.length * this.context.sampleRate);\r\n\t\tvar rBuffer = new Float32Array(this.length * this.context.sampleRate);\r\n\t\tfor(let i = 0; i < this.length * this.context.sampleRate; i++) {\r\n\t\t\tlBuffer[i] = Math.random();\r\n\t\t\trBuffer[i] = Math.random();\r\n\t\t}\r\n\t\tlet buffer = this.context.createBuffer(2, this.length * this.context.sampleRate, this.context.sampleRate);\r\n\t\tbuffer.copyToChannel(lBuffer,0);\r\n\t\tbuffer.copyToChannel(rBuffer,1);\r\n\r\n\t\tlet osc = this.context.createBufferSource({\r\n\t\t\tbuffer: buffer,\r\n\t\t\tloop: true,\r\n\t\t\tloopStart: 0,\r\n\t\t\tloopEnd: 2\r\n\t\t});\r\n\r\n\t\t\tosc.start(this.context.currentTime);\r\n\t\t\tosc.connect(this.ampEnvelope.output);\r\n\t\tthis.partials.push(osc);\r\n\t}\r\n\r\n\ton(MidiEvent) {\r\n\t\tthis.value = MidiEvent.value;\r\n\t\tthis.ampEnvelope.on(MidiEvent.velocity || MidiEvent);\r\n\t}\r\n\r\n}\n\nclass Reverb extends Effect {\r\n\tconstructor (context) {\r\n\t\tsuper(context);\r\n\t\tthis.attack = 0;\r\n\t\tthis.decay = 0.2;\r\n\t\tthis.release = 0.2;\r\n\t}\r\n\r\n\tsetup () {\r\n\t\tthis.effect = this.context.createConvolver();\r\n\r\n\t\tthis.reverbTime = 1;\r\n\r\n\t\tthis.wet = this.context.createGain();\r\n\t\tthis.wet.gain.value = 0.4;\r\n\t\tthis.dry = this.context.createGain();\r\n\t\tthis.dry.gain.value = 0.8;\r\n\r\n\t\tthis.buffer = this.renderTail();\r\n\r\n\t}\r\n\r\n\twireUp() {\r\n\t\tthis.input.connect(this.dry);\r\n\t\tthis.input.connect(this.effect);\r\n\r\n\t\tthis.dry.connect(this.output);\r\n\t\tthis.effect.connect(this.wet);\r\n\t\tthis.wet.connect(this.output);\r\n\t}\r\n\r\n\trenderTail () {\r\n\t\tlet tailContext = new OfflineAudioContext(2, this.context.sampleRate * this.reverbTime, this.context.sampleRate);\r\n\t\tlet buffer = tailContext.createBufferSource();\r\n\t\tlet tail = new Noise(tailContext, 1);\r\n\t\ttail.init();\r\n\t\ttail.connect(tailContext.destination);\r\n\t\ttail.attack = this.attack;\r\n\t\ttail.decay = this.decay;\r\n\t\ttail.release = this.release;\r\n\t\ttail.on(100);\r\n\t\ttail.off();\r\n\t\treturn tailContext.startRendering().then((buffer) => {\r\n\t\t\tthis.effect.buffer = buffer;\r\n\t\t});\r\n\t}\r\n}\n\nclass ComplexVoice extends Voice {\r\n\r\n\tconstructor (context, type, amount = 3, wideness = 50, analog = 5) {\r\n\t\tsuper(context, \"none\");\r\n\t\tthis.type = type;\r\n\t\tthis.widen = wideness;\r\n\t\tthis.analog = analog;\r\n\t\tthis.amount = amount;\r\n\t\tthis.output.gain.value = 1/amount;\r\n\t}\r\n\r\n\tinit () {\r\n\t\tvar amount = this.amount;\r\n\r\n\t\tfor (let i = 0; i < amount; i++) {\r\n\t\t\tlet osc = this.context.createOscillator();\r\n\t\t\tosc.type = this.type;\r\n\t\t\tif (i > 0) {\r\n\t\t\t\tvar detune = (i / amount * this.widen);\r\n\t\t\t\tif (i % 1 == 0) {\r\n\t\t\t\t\tdetune = -detune;\r\n\t\t\t\t}\r\n\t\t\t\tosc.detune.value = detune + (this.analog * Math.random());\r\n\t\t\t}\r\n\t\t\tosc.connect(this.ampEnvelope.output);\r\n\t\t\tosc.start(this.context.currentTime);\r\n\t\t\tthis.partials.push(osc);\r\n\t\t}\r\n\t}\r\n\r\n\tset wideness (value) {\r\n\t\tthis.widen = value;\r\n\t\tvar amount = this.amount;\r\n\r\n\t\tthis.partials.forEach((osc, i) => {\r\n\t\t\tif (i > 0) {\r\n\t\t\t\tvar detune = (i / amount * this.widen);\r\n\t\t\t\tif (i % 1 == 0) {\r\n\t\t\t\t\tdetune = -detune;\r\n\t\t\t\t}\r\n\t\t\t\tosc.detune.value = detune + (this.analog * Math.random());\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tget wideness () {\r\n\t\treturn this.widen;\r\n\t}\r\n}\n\nclass SamplePlayer extends Voice {\r\n\r\n\tconstructor (context, buffer, loop = true, sampleTuneFrequency = BASE_SAMPLE_TUNING) {\r\n\t\tsuper(context);\r\n\t\tthis.buffer = this.context.createBufferSource(buffer);\r\n\t\tthis.buffer.buffer = buffer;\r\n\t\tthis.loop = loop;\r\n\t\tthis.sampleTuneFrequency = sampleTuneFrequency;\r\n\t}\r\n\r\n\tinit () {\r\n\t\tlet osc = this.buffer;\r\n\t\tosc.connect(this.ampEnvelope.output);\r\n\t\tosc.loop = this.loop;\r\n\t\tthis.partials.push(osc);\r\n\r\n\t}\r\n\r\n\ton (MidiEvent) {\r\n\t\tlet frequency = MidiEvent.frequency;\r\n\t\tthis.value = MidiEvent.value;\r\n\t\tthis.partials.forEach((osc) => {\r\n\t\t\tosc.start(this.context.currentTime);\r\n\t\t\tosc.playbackRate.value = frequency / this.sampleTuneFrequency;\r\n\t\t});\r\n\t\tthis.ampEnvelope.on(MidiEvent.velocity || MidiEvent);\r\n\t}\r\n\r\n}\n\nclass MizzyDevice {\r\n\tconstructor(context) {\r\n\t\tthis.context = context;\r\n\t\tthis.output = this.context.createGain();\r\n\t\tthis.effectInput = this.output;\r\n\t\tthis.voices = [];\r\n\t\tthis.effects = [];\r\n\t\tthis.effectInput = this.output;\r\n\t}\r\n\r\n\tNoteOn(MidiEvent) {\r\n\r\n\t}\r\n\r\n\tNoteOff (MidiEvent) {\r\n\t\tthis.voices[MidiEvent.value].off(MidiEvent);\r\n\t}\r\n\r\n\tonCC (MidiEvent) {\r\n\r\n\t}\r\n\r\n\taddEffect (effect, options) {\r\n\t\tthis.effects.push(new effect(this.context));\r\n\t}\r\n\r\n\tconnectEffects () {\r\n\t\tthis.effectInput = this.effects[0].input;\r\n\t\tfor (let i = this.effects.length - 1; i >= 0; i--) {\r\n\t\t\tconsole.log(this.effects[i]);\r\n\t\t\tif (i == this.effects.length - 1) {\r\n\t\t\t\tthis.effects[i].connect(this.output);\r\n\t\t\t} else {\r\n\t\t\t\tthis.effects[i].connect(this.effects[i + 1].input);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tconnect (destination) {\r\n\t\tthis.output.connect(destination);\r\n\t}\r\n\tdisconnect (destination) {\r\n\t\tthis.output.disconnect(destination);\r\n\t}\r\n}\n\nclass VSS30 extends MizzyDevice {\r\n\r\n\tconstructor (context) {\r\n\t\tsuper(context);\r\n\t\tthis.sample = new Sample(this.context);\r\n\t\tthis.recording = false;\r\n\t}\r\n\r\n\trecord(timeout = null) {\r\n\t\tif(!this.recording) {\r\n\t\t\tconsole.log(\"recording...\");\r\n\t\t\tthis.recording = true;\r\n\t\t\tthis.sample.record();\r\n\t\t\tif(timeout!=null) {\r\n\t\t\t\tsetTimeout(() => this.stopRecording(), timeout);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tstopRecording() {\r\n\t\tif(this.recording) {\r\n\t\t\tthis.recording = false;\r\n\t\t\tthis.sample.stopRecording();\r\n\t\t\tconsole.log(\"stop recording.\", this.sample.buffer.length);\r\n\t\t}\r\n\t}\r\n\r\n\tNoteOn (MidiEvent) {\r\n\t\tlet voice = new SamplePlayer(this.context, this.sample.buffer, true);\r\n\t\tvoice.init();\r\n\t\tvoice.connect(this.effectInput);\r\n\t\tvoice.on(MidiEvent);\r\n\t\tthis.voices[MidiEvent.value] = voice;\r\n\t}\r\n\r\n}\n\nclass Vincent extends MizzyDevice {\r\n\r\n\tconstructor (context, count, type = \"sawtooth\", wideness = 50) {\r\n\t\tsuper(context);\r\n\t\tthis.oscillatorType = type;\r\n\t\tthis.numberOfOscillators = count;\r\n\t\tthis._wideness = wideness;\r\n\t}\r\n\r\n\tNoteOn (MidiEvent) {\r\n\t\tlet voice = new ComplexVoice(this.context, this.oscillatorType, this.numberOfOscillators);\r\n\t\tvoice.init();\r\n\t\tvoice.connect(this.effectInput);\r\n\t\tvoice.on(MidiEvent);\r\n\t\tthis.voices[MidiEvent.value] = voice;\r\n\t}\r\n\r\n\tset wideness (value) {\r\n\t\tthis._wideness = value;\r\n\t\tthis.voices.forEach((voice) => voice.wideness = this._wideness);\r\n\t}\r\n\r\n\tget wideness () {\r\n\t\treturn this._wideness;\r\n\t}\r\n\r\n\tset type (value) {\r\n\r\n\t}\r\n\r\n}\n\nconst Components = {FilterEnvelope: Filter, AmpEnvelope, Sample};\r\nconst Effects = {Chorus, Delay, Filter: Filter$1, Reverb, FFT};\r\nconst Voices =   {ComplexVoice, Noise, SamplePlayer, Voice};\r\nconst Synths = {VSS30, Vincent};\n\nexport { Components, Effects, Voices, Synths };\n"],"file":"scream.es6.js"}
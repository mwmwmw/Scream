{"version":3,"names":[],"mappings":"","sources":["scream.js"],"sourcesContent":["(function (exports) {\n'use strict';\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar AmpEnvelope = function () {\n\tfunction AmpEnvelope(context) {\n\t\tvar gain = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\t\tclassCallCheck(this, AmpEnvelope);\n\n\t\tthis.context = context;\n\t\tthis.output = this.context.createGain();\n\t\tthis.output.gain.value = gain;\n\t\tthis.partials = [];\n\t\tthis.velocity = 0;\n\t\tthis.gain = gain;\n\t\tthis._attack = 0;\n\t\tthis._decay = 0.001;\n\t\tthis._sustain = this.output.gain.value;\n\t\tthis._release = 0.001;\n\t}\n\n\tcreateClass(AmpEnvelope, [{\n\t\tkey: \"on\",\n\t\tvalue: function on(velocity) {\n\t\t\tthis.velocity = velocity / 127;\n\t\t\tthis.start(this.context.currentTime);\n\t\t}\n\t}, {\n\t\tkey: \"off\",\n\t\tvalue: function off(MidiEvent) {\n\t\t\treturn this.stop(this.context.currentTime);\n\t\t}\n\t}, {\n\t\tkey: \"start\",\n\t\tvalue: function start(time) {\n\t\t\tthis.output.gain.value = 0;\n\t\t\tthis.output.gain.setValueAtTime(0, time);\n\t\t\treturn this.output.gain.setTargetAtTime(this.sustain * this.velocity, time + this.attack, this.decay + 0.001);\n\t\t}\n\t}, {\n\t\tkey: \"stop\",\n\t\tvalue: function stop(time) {\n\t\t\tthis.output.gain.cancelScheduledValues(time);\n\t\t\tthis.output.gain.setValueAtTime(this.sustain, time);\n\t\t\tthis.output.gain.setTargetAtTime(0, time, this.release);\n\t\t}\n\t}, {\n\t\tkey: \"connect\",\n\t\tvalue: function connect(destination) {\n\t\t\tthis.output.connect(destination);\n\t\t}\n\t}, {\n\t\tkey: \"attack\",\n\t\tset: function set$$1(value) {\n\t\t\tthis._attack = value;\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this._attack;\n\t\t}\n\t}, {\n\t\tkey: \"decay\",\n\t\tset: function set$$1(value) {\n\t\t\tthis._decay = value;\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this._decay;\n\t\t}\n\t}, {\n\t\tkey: \"sustain\",\n\t\tset: function set$$1(value) {\n\t\t\tthis.gain = value;\n\t\t\tthis._sustain;\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this.gain;\n\t\t}\n\t}, {\n\t\tkey: \"release\",\n\t\tset: function set$$1(value) {\n\t\t\tthis._release = value;\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this._release;\n\t\t}\n\t}]);\n\treturn AmpEnvelope;\n}();\n\nvar FILTER_TYPES = [\"lowpass\", \"highpass\", \"bandpass\", \"lowshelf\", \"highshelf\", \"peaking\", \"notch\", \"allpass\"];\n\nvar BASE_SAMPLE_TUNING = 261.625565; // Middle C.\n\nvar Filter = function () {\n\tfunction Filter(context) {\n\t\tvar type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FILTER_TYPES[0];\n\t\tvar cutoff = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;\n\t\tvar resonance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.1;\n\t\tclassCallCheck(this, Filter);\n\n\t\tthis.context = context;\n\t\tthis.destination = this.context.createBiquadFilter();\n\t\tthis.type = type;\n\t\tthis.cutoff = cutoff;\n\t\tthis.resonance = 0.5;\n\t\tthis.envelopeAmount = 1;\n\t\tthis.envelope = {\n\t\t\ta: 0,\n\t\t\td: 0.5,\n\t\t\ts: this.cutoff,\n\t\t\tr: 0.5\n\t\t};\n\t}\n\n\tcreateClass(Filter, [{\n\t\tkey: \"on\",\n\t\tvalue: function on(MidiEvent) {\n\t\t\tthis.start(this.context.currentTime, MidiEvent.frequency);\n\t\t}\n\t}, {\n\t\tkey: \"off\",\n\t\tvalue: function off() {\n\t\t\treturn this.stop(this.context.currentTime);\n\t\t}\n\t}, {\n\t\tkey: \"start\",\n\t\tvalue: function start(time) {\n\t\t\treturn this.destination.frequency.setTargetAtTime(this.sustain, time + this.attack, this.decay + 0.001);\n\t\t}\n\t}, {\n\t\tkey: \"stop\",\n\t\tvalue: function stop(time) {\n\t\t\treturn this.destination.frequency.setTargetAtTime(this.cutoff, time, this.release);\n\t\t}\n\t}, {\n\t\tkey: \"connect\",\n\t\tvalue: function connect(destination) {\n\t\t\tthis.destination.connect(destination);\n\t\t}\n\t}, {\n\t\tkey: \"type\",\n\t\tset: function set$$1(value) {\n\t\t\tthis.destination.type = value;\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this.destination.type;\n\t\t}\n\t}, {\n\t\tkey: \"cutoff\",\n\t\tset: function set$$1(value) {\n\t\t\tthis.destination.frequency.value = value;\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this.destination.frequency.value;\n\t\t}\n\t}, {\n\t\tkey: \"Q\",\n\t\tset: function set$$1(value) {\n\t\t\tthis.destination.Q.value = value;\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this.destination.Q.value;\n\t\t}\n\t}, {\n\t\tkey: \"attack\",\n\t\tset: function set$$1(value) {\n\t\t\tthis.envelope.a = value;\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this.envelope.a;\n\t\t}\n\t}, {\n\t\tkey: \"decay\",\n\t\tset: function set$$1(value) {\n\t\t\tthis.envelope.d = value;\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this.envelope.d;\n\t\t}\n\t}, {\n\t\tkey: \"sustain\",\n\t\tset: function set$$1(value) {\n\t\t\tthis.cutoff = value;\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this.cutoff;\n\t\t}\n\t}, {\n\t\tkey: \"release\",\n\t\tset: function set$$1(value) {\n\t\t\tthis.envelope.r = value;\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this.envelope.r;\n\t\t}\n\t}]);\n\treturn Filter;\n}();\n\nvar SAMPLE_BUFFER_SIZE = 1024;\n\nvar Sample = function () {\n\tfunction Sample(context) {\n\t\tclassCallCheck(this, Sample);\n\n\n\t\tthis.context = context;\n\t\tthis.buffer = this.context.createBuffer(2, 1, this.context.sampleRate);\n\t\tthis.stream = null;\n\t\tthis._recordProcessor = null;\n\t}\n\n\tcreateClass(Sample, [{\n\t\tkey: \"load\",\n\t\tvalue: function load(path) {\n\t\t\tvar _this = this;\n\n\t\t\treturn fetch(path).then(function (response) {\n\t\t\t\treturn response.arrayBuffer();\n\t\t\t}).then(function (myBlob) {\n\t\t\t\treturn _this.context.decodeAudioData(myBlob);\n\t\t\t}).then(function (buffer) {\n\t\t\t\t_this.buffer = buffer;\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"record\",\n\t\tvalue: function record() {\n\t\t\tvar _this2 = this;\n\n\t\t\tthis.buffered = 0;\n\t\t\tthis.stream = new Float32Array(0);\n\t\t\tnavigator.mediaDevices.getUserMedia({ audio: true, video: false }).then(function (stream) {\n\t\t\t\tvar input = _this2.context.createMediaStreamSource(stream);\n\t\t\t\t_this2._recordProcessor = _this2.context.createScriptProcessor(SAMPLE_BUFFER_SIZE, 1, 2);\n\n\t\t\t\tinput.connect(_this2._recordProcessor);\n\t\t\t\t_this2._recordProcessor.connect(_this2.context.destination);\n\t\t\t\t_this2._recordProcessor.onaudioprocess = function (e) {\n\t\t\t\t\tvar chunk = e.inputBuffer.getChannelData(0);\n\t\t\t\t\tvar newStream = new Float32Array(_this2.stream.length + chunk.length);\n\t\t\t\t\tnewStream.set(_this2.stream);\n\t\t\t\t\tnewStream.set(chunk, chunk.length * _this2.buffered);\n\t\t\t\t\t_this2.stream = newStream;\n\t\t\t\t\t_this2.buffered++;\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"stopRecording\",\n\t\tvalue: function stopRecording() {\n\t\t\tthis._recordProcessor.disconnect();\n\t\t\tthis.buffer = this.context.createBuffer(2, this.stream.length, this.context.sampleRate);\n\t\t\tthis.buffer.copyToChannel(this.stream, 0);\n\t\t\tthis.buffer.copyToChannel(this.stream, 1);\n\t\t}\n\t}, {\n\t\tkey: \"recordInput\",\n\t\tvalue: function recordInput(input) {}\n\t}]);\n\treturn Sample;\n}();\n\nvar SampleMap = function () {\n\tfunction SampleMap(context, sample_map) {\n\t\tclassCallCheck(this, SampleMap);\n\n\t\tthis.context = context;\n\t\tthis.input_map = sample_map;\n\t\tthis.samples = {};\n\t\tthis.loaded = false;\n\t}\n\n\tcreateClass(SampleMap, [{\n\t\tkey: \"load\",\n\t\tvalue: function load() {\n\t\t\tvar _this = this;\n\n\t\t\tvar sampleLoad = [];\n\t\t\tthis.input_map.forEach(function (sample) {\n\t\t\t\tvar newsample = new Sample(_this.context);\n\t\t\t\tnewsample.load(sample.src).then(function () {\n\t\t\t\t\t_this.samples[sample.value] = Object.assign(sample, { sample: newsample });\n\t\t\t\t});\n\t\t\t\tsampleLoad.push(newsample);\n\t\t\t});\n\t\t\treturn Promise.all(sampleLoad);\n\t\t}\n\t}]);\n\treturn SampleMap;\n}();\n\nvar Effect = function () {\n\tfunction Effect(context) {\n\t\tclassCallCheck(this, Effect);\n\n\t\tthis.name = \"effect\";\n\t\tthis.context = context;\n\t\tthis.input = this.context.createGain();\n\t\tthis.effect = null;\n\t\tthis.output = this.context.createGain();\n\t\tthis.setup();\n\t\tthis.wireUp();\n\t}\n\n\tcreateClass(Effect, [{\n\t\tkey: \"setup\",\n\t\tvalue: function setup() {\n\t\t\tthis.effect = this.context.createGain();\n\t\t}\n\t}, {\n\t\tkey: \"wireUp\",\n\t\tvalue: function wireUp() {\n\t\t\tthis.input.connect(this.effect);\n\t\t\tthis.effect.connect(this.output);\n\t\t}\n\t}, {\n\t\tkey: \"connect\",\n\t\tvalue: function connect(destination) {\n\t\t\tthis.output.connect(destination);\n\t\t}\n\t}]);\n\treturn Effect;\n}();\n\nvar Chorus = function (_Effect) {\n\tinherits(Chorus, _Effect);\n\n\tfunction Chorus() {\n\t\tclassCallCheck(this, Chorus);\n\n\t\tvar _this = possibleConstructorReturn(this, (Chorus.__proto__ || Object.getPrototypeOf(Chorus)).call(this));\n\n\t\t_this.name = \"chorus\";\n\t\treturn _this;\n\t}\n\n\treturn Chorus;\n}(Effect);\n\nvar Filter$1 = function (_Effect) {\n\tinherits(Filter, _Effect);\n\n\tfunction Filter(context) {\n\t\tvar type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FILTER_TYPES[0];\n\t\tvar cutoff = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;\n\t\tvar resonance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.9;\n\t\tclassCallCheck(this, Filter);\n\n\t\tvar _this = possibleConstructorReturn(this, (Filter.__proto__ || Object.getPrototypeOf(Filter)).call(this, context));\n\n\t\t_this.name = \"filter\";\n\t\t_this.effect.frequency.value = cutoff;\n\t\t_this.effect.Q.value = resonance;\n\t\t_this.effect.type = type;\n\t\treturn _this;\n\t}\n\n\tcreateClass(Filter, [{\n\t\tkey: \"setup\",\n\t\tvalue: function setup() {\n\t\t\tthis.effect = this.context.createBiquadFilter();\n\t\t\tthis.effect.connect(this.output);\n\t\t}\n\t}]);\n\treturn Filter;\n}(Effect);\n\nvar Delay = function (_Effect) {\n\tinherits(Delay, _Effect);\n\n\tfunction Delay(context) {\n\t\tclassCallCheck(this, Delay);\n\n\t\tvar _this = possibleConstructorReturn(this, (Delay.__proto__ || Object.getPrototypeOf(Delay)).call(this, context));\n\n\t\t_this.name = \"delay\";\n\t\treturn _this;\n\t}\n\n\tcreateClass(Delay, [{\n\t\tkey: \"setup\",\n\t\tvalue: function setup() {\n\t\t\tthis.effect = this.context.createDelay();\n\t\t\tthis.effect.delayTime.value = 0.5;\n\t\t\tthis.dry = this.context.createGain();\n\t\t\tthis.wet = this.context.createGain();\n\t\t\tthis.feedback = this.context.createGain();\n\t\t\tthis.feedback.gain.value = 0.75;\n\t\t\tthis.filter = new Filter$1(this.context, \"bandpass\", 1000, 0.3);\n\t\t}\n\t}, {\n\t\tkey: \"wireUp\",\n\t\tvalue: function wireUp() {\n\n\t\t\tthis.input.connect(this.dry);\n\t\t\tthis.dry.connect(this.output);\n\t\t\tthis.wet.connect(this.output);\n\n\t\t\tthis.input.connect(this.effect);\n\t\t\tthis.effect.connect(this.wet);\n\n\t\t\tthis.effect.connect(this.filter.input);\n\t\t\tthis.filter.connect(this.feedback);\n\t\t\tthis.feedback.connect(this.effect);\n\t\t}\n\t}, {\n\t\tkey: \"feedbackAmount\",\n\t\tset: function set$$1(value) {\n\t\t\tvar normalizedValue = value;\n\t\t\tif (normalizedValue > 0.98) {\n\t\t\t\tnormalizedValue = 0.98;\n\t\t\t}\n\t\t\tthis.feedback.gain.value = normalizedValue;\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this.feedback.gain.value;\n\t\t}\n\t}, {\n\t\tkey: \"filterFrequency\",\n\t\tset: function set$$1(value) {\n\t\t\tthis.filter.effect.frequency.value = value;\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this.filter.effect.frequency.value;\n\t\t}\n\t}, {\n\t\tkey: \"filterQ\",\n\t\tset: function set$$1(value) {\n\t\t\tthis.filter.effect.Q.value = value;\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this.filter.effect.Q.value;\n\t\t}\n\t}]);\n\treturn Delay;\n}(Effect);\n\nvar FFT = function (_Effect) {\n\tinherits(FFT, _Effect);\n\n\tfunction FFT(context) {\n\t\tclassCallCheck(this, FFT);\n\n\t\tvar _this = possibleConstructorReturn(this, (FFT.__proto__ || Object.getPrototypeOf(FFT)).call(this, context));\n\n\t\t_this.name = \"fft\";\n\t\treturn _this;\n\t}\n\n\tcreateClass(FFT, [{\n\t\tkey: \"setup\",\n\t\tvalue: function setup() {\n\t\t\tthis.canvas = document.createElement(\"canvas\");\n\t\t\tthis.canvas.setAttribute(\"id\", \"fft\");\n\t\t\tthis.ctx = this.canvas.getContext(\"2d\");\n\t\t\tthis.ctx.canvas.width = 1024;\n\t\t\tthis.ctx.canvas.height = 400;\n\t\t\tthis.effect = this.context.createAnalyser();\n\t\t\tthis.effect.fftSize = 1024;\n\t\t\tthis.effect.maxDecibels = -50;\n\t\t\tthis.effect.minDecibels = -120;\n\t\t\tthis.effect.smoothingTimeConstant = 0.9;\n\t\t\tthis.effect.connect(this.output);\n\t\t}\n\t}, {\n\t\tkey: \"draw\",\n\t\tvalue: function draw() {\n\t\t\tvar _this2 = this;\n\n\t\t\tvar myDataArray = new Uint8Array(this.effect.frequencyBinCount);\n\t\t\tthis.effect.getByteFrequencyData(myDataArray);\n\n\t\t\tvar ctx = this.ctx;\n\t\t\tctx.save();\n\t\t\tctx.globalAlpha = 0.5;\n\t\t\tctx.fillStyle = \"rgb(33,33,99)\";\n\t\t\tctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\t\t\tctx.restore();\n\t\t\tvar i = 0;\n\t\t\tvar width = ctx.canvas.width / myDataArray.length;\n\n\t\t\tfor (var point in myDataArray) {\n\t\t\t\tctx.fillStyle = \"rgb(100,255,255)\";\n\t\t\t\tctx.fillRect(width * i, ctx.canvas.height, width, -(myDataArray[point] / 255) * ctx.canvas.height);\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\twindow.requestAnimationFrame(function () {\n\t\t\t\t_this2.draw();\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"addToElement\",\n\t\tvalue: function addToElement(element) {\n\t\t\telement.appendChild(this.element);\n\t\t}\n\t}, {\n\t\tkey: \"element\",\n\t\tget: function get$$1() {\n\t\t\treturn this.canvas;\n\t\t}\n\t}]);\n\treturn FFT;\n}(Effect);\n\nvar Voice = function () {\n\tfunction Voice(context) {\n\t\tvar type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"sawtooth\";\n\t\tvar gain = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;\n\t\tclassCallCheck(this, Voice);\n\n\t\tthis.context = context;\n\t\tthis.type = type;\n\t\tthis.value = -1;\n\t\tthis.gain = gain;\n\t\tthis.output = this.context.createGain();\n\t\tthis.partials = [];\n\t\tthis.output.gain.value = this.gain;\n\t\tthis.ampEnvelope = new AmpEnvelope(this.context);\n\t\tthis.ampEnvelope.connect(this.output);\n\t}\n\n\tcreateClass(Voice, [{\n\t\tkey: \"init\",\n\t\tvalue: function init() {\n\t\t\tvar osc = this.context.createOscillator();\n\t\t\tosc.type = this.type;\n\t\t\tosc.connect(this.ampEnvelope.output);\n\t\t\tosc.start(this.context.currentTime);\n\t\t\tthis.partials.push(osc);\n\t\t}\n\t}, {\n\t\tkey: \"on\",\n\t\tvalue: function on(MidiEvent) {\n\t\t\tthis.value = MidiEvent.value;\n\t\t\tthis.partials.forEach(function (osc) {\n\t\t\t\tosc.frequency.value = MidiEvent.frequency;\n\t\t\t});\n\t\t\tthis.ampEnvelope.on(MidiEvent.velocity || MidiEvent);\n\t\t}\n\t}, {\n\t\tkey: \"off\",\n\t\tvalue: function off(MidiEvent) {\n\t\t\tvar _this = this;\n\n\t\t\tthis.ampEnvelope.off(MidiEvent);\n\t\t\tthis.partials.forEach(function (osc) {\n\t\t\t\tosc.stop(_this.context.currentTime + _this.ampEnvelope.release * 4);\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"connect\",\n\t\tvalue: function connect(destination) {\n\t\t\tthis.output.connect(destination);\n\t\t}\n\t}, {\n\t\tkey: \"attack\",\n\t\tset: function set$$1(value) {\n\t\t\tthis.ampEnvelope.attack = value;\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this.ampEnvelope.attack;\n\t\t}\n\t}, {\n\t\tkey: \"decay\",\n\t\tset: function set$$1(value) {\n\t\t\tthis.ampEnvelope.decay = value;\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this.ampEnvelope.decay;\n\t\t}\n\t}, {\n\t\tkey: \"sustain\",\n\t\tset: function set$$1(value) {\n\t\t\tthis.ampEnvelope.sustain = value;\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this.ampEnvelope.sustain;\n\t\t}\n\t}, {\n\t\tkey: \"release\",\n\t\tset: function set$$1(value) {\n\t\t\tthis.ampEnvelope.release = value;\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this.ampEnvelope.release;\n\t\t}\n\t}]);\n\treturn Voice;\n}();\n\nvar Noise = function (_Voice) {\n\tinherits(Noise, _Voice);\n\n\tfunction Noise(context, gain) {\n\t\tclassCallCheck(this, Noise);\n\n\t\tvar _this = possibleConstructorReturn(this, (Noise.__proto__ || Object.getPrototypeOf(Noise)).call(this, context, gain));\n\n\t\t_this._length = 2;\n\t\treturn _this;\n\t}\n\n\tcreateClass(Noise, [{\n\t\tkey: \"init\",\n\t\tvalue: function init() {\n\t\t\tvar lBuffer = new Float32Array(this.length * this.context.sampleRate);\n\t\t\tvar rBuffer = new Float32Array(this.length * this.context.sampleRate);\n\t\t\tfor (var i = 0; i < this.length * this.context.sampleRate; i++) {\n\t\t\t\tlBuffer[i] = Math.random();\n\t\t\t\trBuffer[i] = Math.random();\n\t\t\t}\n\t\t\tvar buffer = this.context.createBuffer(2, this.length * this.context.sampleRate, this.context.sampleRate);\n\t\t\tbuffer.copyToChannel(lBuffer, 0);\n\t\t\tbuffer.copyToChannel(rBuffer, 1);\n\n\t\t\tvar osc = this.context.createBufferSource();\n\t\t\tosc.buffer = buffer;\n\t\t\tosc.loop = true;\n\t\t\tosc.loopStart = 0;\n\t\t\tosc.loopEnd = 2;\n\n\t\t\tosc.start(this.context.currentTime);\n\t\t\tosc.connect(this.ampEnvelope.output);\n\t\t\tthis.partials.push(osc);\n\t\t}\n\t}, {\n\t\tkey: \"on\",\n\t\tvalue: function on(MidiEvent) {\n\t\t\tthis.value = MidiEvent.value;\n\t\t\tthis.ampEnvelope.on(MidiEvent.velocity || MidiEvent);\n\t\t}\n\t}, {\n\t\tkey: \"length\",\n\t\tget: function get$$1() {\n\t\t\treturn this._length || 2;\n\t\t},\n\t\tset: function set$$1(value) {\n\t\t\tthis._length = value;\n\t\t}\n\t}]);\n\treturn Noise;\n}(Voice);\n\nvar Reverb = function (_Effect) {\n\tinherits(Reverb, _Effect);\n\n\tfunction Reverb(context) {\n\t\tclassCallCheck(this, Reverb);\n\n\t\tvar _this = possibleConstructorReturn(this, (Reverb.__proto__ || Object.getPrototypeOf(Reverb)).call(this, context));\n\n\t\t_this.name = \"reverb\";\n\t\t_this.attack = 0;\n\t\t_this.decay = 0.2;\n\t\t_this.release = 0.8;\n\t\treturn _this;\n\t}\n\n\tcreateClass(Reverb, [{\n\t\tkey: \"setup\",\n\t\tvalue: function setup() {\n\t\t\tthis.effect = this.context.createConvolver();\n\n\t\t\tthis.reverbTime = 2;\n\n\t\t\tthis.attack = 0;\n\t\t\tthis.decay = 0.2;\n\t\t\tthis.release = 0.8;\n\n\t\t\tthis.wet = this.context.createGain();\n\t\t\tthis.wet.gain.value = 1;\n\t\t\tthis.dry = this.context.createGain();\n\t\t\tthis.dry.gain.value = 1;\n\n\t\t\tthis.buffer = this.renderTail();\n\t\t\tthis.wireUp();\n\t\t}\n\t}, {\n\t\tkey: \"wireUp\",\n\t\tvalue: function wireUp() {\n\t\t\tthis.input.connect(this.dry);\n\t\t\tthis.input.connect(this.effect);\n\n\t\t\tthis.dry.connect(this.output);\n\t\t\tthis.effect.connect(this.wet);\n\t\t\tthis.wet.connect(this.output);\n\t\t}\n\t}, {\n\t\tkey: \"renderTail\",\n\t\tvalue: function renderTail() {\n\t\t\tvar _this2 = this;\n\n\t\t\tvar tailContext = new OfflineAudioContext(2, this.context.sampleRate * this.reverbTime, this.context.sampleRate);\n\t\t\t//let buffer = tailContext.createBufferSource();\n\t\t\tvar tail = new Noise(tailContext, 1);\n\t\t\ttail.init();\n\t\t\ttail.connect(tailContext.destination);\n\t\t\ttail.attack = this.attack;\n\t\t\ttail.decay = this.decay;\n\t\t\ttail.release = this.release;\n\t\t\ttail.on(100);\n\t\t\ttail.off();\n\t\t\treturn tailContext.startRendering().then(function (buffer) {\n\n\t\t\t\t// this.source = this.context.createBufferSource(buffer);\n\t\t\t\t// this.source.buffer = buffer;\n\t\t\t\t// this.source.start();\n\t\t\t\t// this.source.connect(this.output);\n\n\t\t\t\t_this2.effect.buffer = buffer;\n\t\t\t\tconsole.log(buffer, _this2.effect);\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"decayTime\",\n\t\tset: function set$$1(value) {\n\t\t\tvar dc = value / 3;\n\t\t\tthis.reverbTime = value;\n\t\t\tthis.attack = 0;\n\t\t\tthis.decay = dc;\n\t\t\tthis.release = dc;\n\t\t\tthis.buffer = this.renderTail();\n\t\t}\n\t}]);\n\treturn Reverb;\n}(Effect);\n\nvar MAX = 1;\nvar MIN = 0;\nvar DEFAULT = 1;\nvar WINDOW_SIZE = 512;\n\nvar Saturate = function (_Effect) {\n\tinherits(Saturate, _Effect);\n\n\tfunction Saturate(context) {\n\t\tclassCallCheck(this, Saturate);\n\n\t\tvar _this = possibleConstructorReturn(this, (Saturate.__proto__ || Object.getPrototypeOf(Saturate)).call(this, context));\n\n\t\t_this.name = \"saturate\";\n\t\t_this._amount = DEFAULT;\n\n\t\t_this.canvas = document.createElement(\"canvas\");\n\t\t_this.canvas.setAttribute(\"id\", \"saturate\");\n\t\t_this.ctx = _this.canvas.getContext(\"2d\");\n\t\t_this.ctx.canvas.width = 512;\n\t\t_this.ctx.canvas.height = 512;\n\t\twindow.requestAnimationFrame(function () {\n\t\t\t_this.draw();\n\t\t});\n\t\treturn _this;\n\t}\n\n\tcreateClass(Saturate, [{\n\t\tkey: \"setup\",\n\t\tvalue: function setup() {\n\t\t\tthis.effect = this.context.createWaveShaper();\n\t\t\tthis.effect.curve = this.createCurve();\n\t\t\tconsole.log(this.effect.curve);\n\t\t\tthis.effect.oversample = '4x';\n\t\t}\n\t}, {\n\t\tkey: \"createCurve\",\n\t\tvalue: function createCurve() {\n\t\t\tvar amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT;\n\n\t\t\tvar curve = new Float32Array(WINDOW_SIZE);\n\t\t\tvar x = 0;\n\t\t\tfor (var i = 0; i < WINDOW_SIZE; i++) {\n\t\t\t\tvar x = 1 - i / WINDOW_SIZE * 2;\n\t\t\t\tcurve[i] = this.f(x, amount);\n\t\t\t}\n\n\t\t\treturn curve;\n\t\t}\n\t}, {\n\t\tkey: \"f\",\n\t\tvalue: function f(x) {\n\t\t\tvar range = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT;\n\n\n\t\t\treturn x * range;\n\t\t\t//return Math.sin(Math.pow(Math.cos(Math.PI * (x) / 4.0), 1) * range) * ((range / 0.5) * 1.18) *10;\n\t\t}\n\t}, {\n\t\tkey: \"draw\",\n\t\tvalue: function draw() {\n\t\t\tvar _this2 = this;\n\n\t\t\tvar ctx = this.ctx;\n\t\t\tctx.save();\n\t\t\tctx.globalAlpha = 0.5;\n\t\t\tctx.fillStyle = \"rgb(33,33,99)\";\n\t\t\tctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\t\t\tctx.restore();\n\t\t\tvar width = 1;\n\n\t\t\tfor (var i = 0; i < this.effect.curve.length; i++) {\n\t\t\t\tvar point = this.effect.curve[i];\n\t\t\t\tctx.fillStyle = \"rgb(100,255,255)\";\n\t\t\t\tctx.fillRect(i, WINDOW_SIZE * .5 + point * WINDOW_SIZE, width, 1);\n\t\t\t}\n\n\t\t\twindow.requestAnimationFrame(function () {\n\t\t\t\t_this2.draw();\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"addToElement\",\n\t\tvalue: function addToElement(element) {\n\t\t\telement.appendChild(this.element);\n\t\t}\n\t}, {\n\t\tkey: \"amount\",\n\t\tset: function set$$1(value) {\n\t\t\tthis._amount = 1 + (MIN + value * MAX);\n\t\t\tthis.effect.curve = this.createCurve(this._amount);\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this._amount;\n\t\t}\n\t}, {\n\t\tkey: \"element\",\n\t\tget: function get$$1() {\n\t\t\treturn this.canvas;\n\t\t}\n\t}]);\n\treturn Saturate;\n}(Effect);\n\nvar ComplexVoice = function (_Voice) {\n\tinherits(ComplexVoice, _Voice);\n\n\tfunction ComplexVoice(context, type) {\n\t\tvar amount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;\n\t\tvar wideness = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 50;\n\t\tvar analog = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 5;\n\t\tclassCallCheck(this, ComplexVoice);\n\n\t\tvar _this = possibleConstructorReturn(this, (ComplexVoice.__proto__ || Object.getPrototypeOf(ComplexVoice)).call(this, context, \"none\"));\n\n\t\t_this.type = type;\n\t\t_this.widen = wideness;\n\t\t_this.analog = analog;\n\t\t_this.amount = amount;\n\t\t_this.output.gain.value = 1 / amount;\n\t\treturn _this;\n\t}\n\n\tcreateClass(ComplexVoice, [{\n\t\tkey: \"init\",\n\t\tvalue: function init() {\n\t\t\tvar amount = this.amount;\n\n\t\t\tfor (var i = 0; i < amount; i++) {\n\t\t\t\tvar osc = this.context.createOscillator();\n\t\t\t\tosc.type = this.type;\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tvar detune = i / amount * this.widen;\n\t\t\t\t\tif (i % 1 == 0) {\n\t\t\t\t\t\tdetune = -detune;\n\t\t\t\t\t}\n\t\t\t\t\tosc.detune.value = detune + this.analog * Math.random();\n\t\t\t\t}\n\t\t\t\tosc.connect(this.ampEnvelope.output);\n\t\t\t\tosc.start(this.context.currentTime);\n\t\t\t\tthis.partials.push(osc);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"wideness\",\n\t\tset: function set$$1(value) {\n\t\t\tvar _this2 = this;\n\n\t\t\tthis.widen = value;\n\t\t\tvar amount = this.amount;\n\n\t\t\tthis.partials.forEach(function (osc, i) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tvar detune = i / amount * _this2.widen;\n\t\t\t\t\tif (i % 1 == 0) {\n\t\t\t\t\t\tdetune = -detune;\n\t\t\t\t\t}\n\t\t\t\t\tosc.detune.value = detune + _this2.analog * Math.random();\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this.widen;\n\t\t}\n\t}]);\n\treturn ComplexVoice;\n}(Voice);\n\nvar SamplePlayer = function (_Voice) {\n\tinherits(SamplePlayer, _Voice);\n\n\tfunction SamplePlayer(context, buffer) {\n\t\tvar loop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\t\tvar tune = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\t\tvar sampleTuneFrequency = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : BASE_SAMPLE_TUNING;\n\t\tclassCallCheck(this, SamplePlayer);\n\n\t\tvar _this = possibleConstructorReturn(this, (SamplePlayer.__proto__ || Object.getPrototypeOf(SamplePlayer)).call(this, context));\n\n\t\t_this.buffer = _this.context.createBufferSource(buffer);\n\t\t_this.buffer.buffer = buffer;\n\t\t_this.length = _this.buffer.buffer.duration;\n\t\t_this._loopLength = _this.length;\n\t\t_this.tune = tune;\n\t\t_this.loop = loop;\n\t\t// this.buffer.loopStart = 0;\n\t\t// this.buffer.loopEnd = 0;\n\t\t_this.sampleTuneFrequency = sampleTuneFrequency;\n\t\treturn _this;\n\t}\n\n\tcreateClass(SamplePlayer, [{\n\t\tkey: \"init\",\n\t\tvalue: function init() {\n\t\t\tthis.buffer.connect(this.ampEnvelope.output);\n\t\t\tthis.buffer.loop = this.loop;\n\t\t\tthis.partials.push(this.buffer);\n\t\t}\n\t}, {\n\t\tkey: \"on\",\n\t\tvalue: function on(MidiEvent) {\n\t\t\tvar _this2 = this;\n\n\t\t\tvar frequency = MidiEvent.frequency;\n\t\t\tthis.value = MidiEvent.value;\n\t\t\tthis.partials.forEach(function (osc) {\n\t\t\t\tosc.start(_this2.context.currentTime);\n\t\t\t\tif (_this2.tune) {\n\t\t\t\t\tosc.playbackRate.value = frequency / _this2.sampleTuneFrequency;\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.ampEnvelope.on(MidiEvent.velocity || MidiEvent);\n\t\t}\n\t}, {\n\t\tkey: \"loopStart\",\n\t\tset: function set$$1(value) {\n\t\t\tthis.buffer.loopStart = this.buffer.buffer.duration * value;\n\t\t\tthis.buffer.loopEnd = this.buffer.loopStart + this.loopLength;\n\t\t}\n\t}, {\n\t\tkey: \"loopLength\",\n\t\tset: function set$$1(value) {\n\t\t\tthis._loopLength = value;\n\t\t\tthis.buffer.loopEnd = this.buffer.loopStart + this._loopLength;\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this._loopLength;\n\t\t}\n\t}]);\n\treturn SamplePlayer;\n}(Voice);\n\nvar MizzyDevice = function () {\n\tfunction MizzyDevice(context) {\n\t\tclassCallCheck(this, MizzyDevice);\n\n\t\tthis.context = context;\n\t\tthis.output = this.context.createGain();\n\t\tthis.effectInput = this.output;\n\t\tthis.voices = [];\n\t\tthis.effects = [];\n\t\tthis._attack = 0;\n\t\tthis._decay = 0.001;\n\t\tthis._sustain = this.output.gain.value;\n\t\tthis._release = 0.001;\n\t}\n\n\tcreateClass(MizzyDevice, [{\n\t\tkey: \"NoteOn\",\n\t\tvalue: function NoteOn(MidiEvent) {}\n\t}, {\n\t\tkey: \"NoteOff\",\n\t\tvalue: function NoteOff(MidiEvent) {\n\t\t\tif (this.voices[MidiEvent.value] != undefined) {\n\t\t\t\tthis.voices[MidiEvent.value].off(MidiEvent);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"onCC\",\n\t\tvalue: function onCC(MidiEvent) {}\n\t}, {\n\t\tkey: \"addEffect\",\n\t\tvalue: function addEffect(effect, options) {\n\t\t\tthis.effects.push(new effect(this.context));\n\t\t}\n\t}, {\n\t\tkey: \"connectEffects\",\n\t\tvalue: function connectEffects() {\n\t\t\tthis.effectInput = this.effects[0].input;\n\t\t\tfor (var i = this.effects.length - 1; i >= 0; i--) {\n\t\t\t\tconsole.log(this.effects[i]);\n\t\t\t\tif (i == this.effects.length - 1) {\n\t\t\t\t\tthis.effects[i].connect(this.output);\n\t\t\t\t} else {\n\t\t\t\t\tthis.effects[i].connect(this.effects[i + 1].input);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"connect\",\n\t\tvalue: function connect(destination) {\n\t\t\tthis.output.connect(destination);\n\t\t}\n\t}, {\n\t\tkey: \"disconnect\",\n\t\tvalue: function disconnect(destination) {\n\t\t\tthis.output.disconnect(destination);\n\t\t}\n\t}, {\n\t\tkey: \"setVoiceValues\",\n\t\tvalue: function setVoiceValues() {\n\t\t\tvar _this = this;\n\n\t\t\tthis.voices.forEach(function (voice) {\n\t\t\t\tvoice.attack = _this._attack;\n\t\t\t\tvoice.decay = _this._decay;\n\t\t\t\tvoice.sustain = _this._sustain;\n\t\t\t\tvoice.release = _this._release;\n\t\t\t});\n\t\t}\n\t}]);\n\treturn MizzyDevice;\n}();\n\nvar Vincent = function (_MizzyDevice) {\n\tinherits(Vincent, _MizzyDevice);\n\n\tfunction Vincent(context, count) {\n\t\tvar type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"sawtooth\";\n\t\tvar wideness = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 50;\n\t\tclassCallCheck(this, Vincent);\n\n\t\tvar _this = possibleConstructorReturn(this, (Vincent.__proto__ || Object.getPrototypeOf(Vincent)).call(this, context));\n\n\t\t_this.oscillatorType = type;\n\t\t_this.numberOfOscillators = count;\n\t\t_this._wideness = wideness;\n\t\treturn _this;\n\t}\n\n\tcreateClass(Vincent, [{\n\t\tkey: \"NoteOn\",\n\t\tvalue: function NoteOn(MidiEvent) {\n\t\t\tvar voice = new ComplexVoice(this.context, this.oscillatorType, this.numberOfOscillators);\n\t\t\tvoice.init();\n\t\t\tvoice.connect(this.effectInput);\n\t\t\tvoice.on(MidiEvent);\n\t\t\tthis.voices[MidiEvent.value] = voice;\n\t\t}\n\t}, {\n\t\tkey: \"wideness\",\n\t\tset: function set$$1(value) {\n\t\t\tvar _this2 = this;\n\n\t\t\tthis._wideness = value;\n\t\t\tthis.voices.forEach(function (voice) {\n\t\t\t\treturn voice.wideness = _this2._wideness;\n\t\t\t});\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this._wideness;\n\t\t}\n\t}, {\n\t\tkey: \"type\",\n\t\tset: function set$$1(value) {}\n\t}]);\n\treturn Vincent;\n}(MizzyDevice);\n\nvar VSS30 = function (_MizzyDevice) {\n\tinherits(VSS30, _MizzyDevice);\n\n\tfunction VSS30(context) {\n\t\tclassCallCheck(this, VSS30);\n\n\t\tvar _this = possibleConstructorReturn(this, (VSS30.__proto__ || Object.getPrototypeOf(VSS30)).call(this, context));\n\n\t\t_this.sample = new Sample(_this.context);\n\t\t_this.recording = false;\n\t\t_this._loopStart = 0;\n\t\t_this._loopEnd = 0;\n\t\t_this._loopLength = 1;\n\t\treturn _this;\n\t}\n\n\tcreateClass(VSS30, [{\n\t\tkey: \"record\",\n\t\tvalue: function record() {\n\t\t\tvar _this2 = this;\n\n\t\t\tvar timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n\t\t\tif (!this.recording) {\n\t\t\t\tconsole.log(\"recording...\");\n\t\t\t\tthis.recording = true;\n\t\t\t\tthis.sample.record();\n\t\t\t\tif (timeout != null) {\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\treturn _this2.stopRecording();\n\t\t\t\t\t}, timeout);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"stopRecording\",\n\t\tvalue: function stopRecording() {\n\t\t\tif (this.recording) {\n\t\t\t\tthis.recording = false;\n\t\t\t\tthis.sample.stopRecording();\n\t\t\t\tconsole.log(\"stop recording.\", this.sample.buffer.length);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"NoteOn\",\n\t\tvalue: function NoteOn(MidiEvent) {\n\t\t\tvar voice = new SamplePlayer(this.context, this.sample.buffer, true);\n\t\t\tvoice.init();\n\t\t\tthis.setVoiceValues();\n\t\t\tvoice.connect(this.effectInput);\n\t\t\tvoice.on(MidiEvent);\n\t\t\tthis.voices[MidiEvent.value] = voice;\n\t\t}\n\t}, {\n\t\tkey: \"setVoiceValues\",\n\t\tvalue: function setVoiceValues() {\n\t\t\tvar _this3 = this;\n\n\t\t\tthis.voices.forEach(function (voice) {\n\t\t\t\tvoice.attack = _this3._attack;\n\t\t\t\tvoice.decay = _this3._decay;\n\t\t\t\tvoice.sustain = _this3._sustain;\n\t\t\t\tvoice.release = _this3._release;\n\t\t\t\tvoice.loopStart = _this3._loopStart;\n\t\t\t\t//voice.loopEnd = this._loopEnd;\n\t\t\t\tvoice.loopLength = _this3._loopLength;\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"loopStart\",\n\t\tset: function set$$1(value) {\n\t\t\tthis._loopStart = value;\n\t\t\tthis.setVoiceValues();\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this._loopStart;\n\t\t}\n\t}, {\n\t\tkey: \"loopEnd\",\n\t\tset: function set$$1(value) {\n\t\t\tthis._loopEnd = value;\n\t\t\tthis.setVoiceValues();\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this._loopEnd;\n\t\t}\n\t}, {\n\t\tkey: \"loopLength\",\n\t\tset: function set$$1(value) {\n\t\t\tthis._loopLength = value;\n\t\t\tthis.setVoiceValues();\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this._loopLength;\n\t\t}\n\t}, {\n\t\tkey: \"attack\",\n\t\tset: function set$$1(value) {\n\t\t\tthis._attack = value;\n\t\t\tthis.setVoiceValues();\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this._attack;\n\t\t}\n\t}, {\n\t\tkey: \"decay\",\n\t\tset: function set$$1(value) {\n\t\t\tthis._decay = value;\n\t\t\tthis.setVoiceValues();\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this._decay;\n\t\t}\n\t}, {\n\t\tkey: \"sustain\",\n\t\tset: function set$$1(value) {\n\t\t\tthis._sustain = value;\n\t\t\tthis.setVoiceValues();\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this._sustain;\n\t\t}\n\t}, {\n\t\tkey: \"release\",\n\t\tset: function set$$1(value) {\n\t\t\tthis._release = value;\n\t\t\tthis.setVoiceValues();\n\t\t},\n\t\tget: function get$$1() {\n\t\t\treturn this._release;\n\t\t}\n\t}]);\n\treturn VSS30;\n}(MizzyDevice);\n\nvar DrumMachine = function (_MizzyDevice) {\n\tinherits(DrumMachine, _MizzyDevice);\n\n\tfunction DrumMachine(context, sample_map) {\n\t\tclassCallCheck(this, DrumMachine);\n\n\t\tvar _this = possibleConstructorReturn(this, (DrumMachine.__proto__ || Object.getPrototypeOf(DrumMachine)).call(this, context));\n\n\t\t_this.map = sample_map;\n\t\treturn _this;\n\t}\n\n\tcreateClass(DrumMachine, [{\n\t\tkey: \"NoteOn\",\n\t\tvalue: function NoteOn(MidiEvent) {\n\t\t\tif (this.map.samples[MidiEvent.value] != null) {\n\t\t\t\tvar voice = new SamplePlayer(this.context, this.map.samples[MidiEvent.value].sample.buffer, false, false);\n\t\t\t\tvoice.init();\n\t\t\t\tthis.setVoiceValues();\n\t\t\t\tvoice.connect(this.effectInput);\n\t\t\t\tvoice.on(MidiEvent);\n\t\t\t\tthis.voices[MidiEvent.value] = voice;\n\t\t\t}\n\t\t}\n\t}]);\n\treturn DrumMachine;\n}(MizzyDevice);\n\nvar Components = { FilterEnvelope: Filter, AmpEnvelope: AmpEnvelope, Sample: Sample, SampleMap: SampleMap };\nvar Effects = { Chorus: Chorus, Delay: Delay, Filter: Filter$1, Reverb: Reverb, FFT: FFT, Saturate: Saturate };\nvar Voices = { ComplexVoice: ComplexVoice, Noise: Noise, SamplePlayer: SamplePlayer, Voice: Voice };\nvar Synths = { VSS30: VSS30, Vincent: Vincent, DrumMachine: DrumMachine };\n\nexports.Components = Components;\nexports.Effects = Effects;\nexports.Voices = Voices;\nexports.Synths = Synths;\n\n}((this.Scream = this.Scream || {})));\n"],"file":"scream.js"}